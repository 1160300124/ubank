此军规适用于所有开发工作:
1. 不要重复造轮子,备注:不管JS还是JAVA功能,不要写重复的功能 ,经技术总监或开发经理确认的除外
2. 使用变量而非常量,备注:不管JS还是JAVA功能,能使用变量的则不要使用常量, 禁止在程序中写死数字与中文说明
3. 代码需要进行注释,备注: 代码注释量应占到代码的30%,每功能点需要进行参数说明与实现原因说明
4. 数据库结构\字段类型\备注说明\初始数据 的修改参经技术总监或开发经理确认
5. 数据字典\全局变量需从缓存中读取,禁止直接从数据库频繁读取数据
6. 所有VO禁止直接修改,需新建BO并继承VO
7. 先要进行前置条件判断，在什么情况下才允许操作，然后才能进行操作，禁止暴力直接进行状态变更，否则有极大的数据安全隐患
8. 系统中所有时间段计时均为 00:00:00 - 23:59:59 
============= 我是分割线 ===============
关于品牌，商品，订单的 CODE 实现策略与方法
使用“自增ID”变化的方式实现
大步骤：
>新增获得ID
>ID格式化成CODE并做更新
以数字1000000起步，该值写到常量表中

方式1：单次插入code使用时间戳做初始值，写入数据后得到ID，然后使用1千万与ID进行累加得到新值后更新
伪代码如下
@trans
{
   brandvo =...
   brandvo.setcode(time);
   id = dao.insertSingleAndGetPK(brandvo);
   code = IConsxxx.value + id;
   "update brand set brand_code=code where id=id"
}
方式2：批量插入时，使用时间戳写初始值，然后一条SQL批量更新CODE值，伪代码如下：
@trans{
    insert...
    insert...
    insert...
    insert...
    update brand set brand=convert(10000000+id)  where length(brand)=20
}


================我是分隔线================

【以下问题发生在第一次代码检核时，请各位开发人员注意】

》日志类问题
  1.引用错了日志包，正确的是org.slf4j.Logger,而非org.apache.commons.logging.Log包
  2.日志类的名字必须是当前类的名字
  3.日志必须是private申明类型
  4.在Service层面，日志书写通常是记录业务处理的过程与结果信息，控制器里面是记录入参的一些信息，方便用于调试程序

》自动注入问题
  1. 有注入的代码要与其它代码保持一行
  2. 规范写法： private @Autowired Ixxxxx xxxx;

》后台路径的问题
  1.必须都是二级路径  
  
  
》控制器的问题
  1. 如果有要求，必须明确该方法是否以GET或者POST方式接收数据，如果没有特别要求，需要都以POST方式接收数据 method=RequestMethod.POST
  2. 直接从页面层得到的数据，在进行业务处理之前，需要进行SQL防注入检测，不要直接将得到的数据在数据层面做操作，有极大的安全隐患。使用方法：StringUtil.isSqlinject
  
》VO的问题
  1.不要手动去建数据库层面的VO，因为它们都在公共包中存在了。
  2.如果需要BO，请自动扩展VO
  
》技巧类
  1.如果要拼装SQL，且参数较多时，需使用String.format方法 ，参中%s表示字符串，%d表示数字
  2.如果要递增或者递减数据库中某字段的值，禁止在VO中采用vo.setvalue(vo.getvalue()+1)的方法来实现，因为VO会缓存值，要在数据库层面采用value=value+1的方式来操作。  
  3.service方法一定要进行事务控制，默认使用：@Transactional(rollbackFor=Exception.class)，特殊的方法需要用到事务传递与锁
  4.后台展示数据时，要考虑三个基本原则：哪些数据是不展示的，哪些是展示的；数据要按何种方式排序是最佳的；友好性原则（不要直接显示数字，要翻译成数据字典中对应的中文）
  

  